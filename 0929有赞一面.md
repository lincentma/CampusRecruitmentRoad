# 有赞一面

> 自己需要提升的是深度而不是广度，需要一直深入到最底层的原理。

## 1. 过往经历的自我介绍

## 2. 多线程管理这方面你是如何去使用的？线程池原理？

> 自己回答的是线程池方面。

> 另外一种是线程组。线程组存在的意义，首要原因是安全。java默认创建的线程都是属于系统线程组，而同一个线程组的线程是可以相互修改对方的数据的。但如果在不同的线程组中，那么就不能“跨线程组”修改数据，可以从一定程度上保证数据安全。

> 线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。

> 线程池的优点：
1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

![](http://image85.360doc.com/DownloadImg/2015/05/1114/53423907_1.jpeg)

> java中常用的线程池类主要有Executors类和ThreadPoolExecutor类。

> 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样
的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。

> Java的线程池实现从根本上来说只有两个：ThreadPoolExecutor类和ScheduledThreadPoolExecutor类，这两个类还是父子关系，但是Java为了简化并行计算，还提供了一个Exceutors的静态类，它可以直接生成多种不同的线程池执行器，比如单线程执行器、带缓冲功能的执行器等，但归根结底还是使用ThreadPoolExecutor类或ScheduledThreadPoolExecutor类的封装类。

> 参数介绍：
1. corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。
2. maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程。
3. keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0。
4. unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性。
5. workQueue：一个阻塞队列，用来存储等待执行的任务。
6. threadFactory：线程工厂，主要用来创建线程。
7. handler：表示当拒绝处理任务时的策略。

> 线程池工作流程：

1. 如果当前池大小 poolSize 小于 corePoolSize ，则创建新线程执行任务。
2. 如果当前池大小 poolSize 大于 corePoolSize ，且等待队列未满，则进入等待队列
3. 如果当前池大小 poolSize 大于 corePoolSize 且小于 maximumPoolSize ，且等待队列已满，则创建新线程执行任务。
4. 如果当前池大小 poolSize 大于 corePoolSize 且大于 maximumPoolSize ，且等待队列已满，则调用拒绝策略来处理该任务。
5. 线程池里的每个线程执行完任务后不会立刻退出，而是会去检查下等待队列里是否还有线程任务需要执行，如果在 keepAliveTime 里等不到新的任务了，那么线程就会退出。

## 3. 线程池的拒绝策略？

1. ThreadPoolExecutor.AbortPolicy         //丢弃任务并抛出RejectedExecutionException异常。
2. ThreadPoolExecutor.DiscardPolicy       //也是丢弃任务，但是不抛出异常。
3. ThreadPoolExecutor.DiscardOldestPolicy //丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
4. ThreadPoolExecutor.CallerRunsPolicy    //由调用线程处理该任务

## 4. 线程池线程数量大小如何确定？

>  一般需要根据任务的类型来配置线程池大小：
- 如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1
- 如果是IO密集型任务，参考值可以设置为2*NCPU

> 原理：

1. 设线程池工作队列长度为m,且m>>n,则此时会导致CPU频繁切换线程来执行(如果CPU使用的是FCFS,则不会频繁切换,如使用的是其他CPU调度算法,如时间片轮转法,最短时间优先,则可能会导致频繁的线程切换)。所以这种情况下,无需设置过大的线程池工作队列,(工作队列长度 = CPU核心数 || CPU核心数+1) 即可。
2. 对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率。(即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。
3. 1个线程对应1个方法栈,线程的生命周期与方法栈相同。
比如某个线程的方法栈对应的入站顺序为:controller()->service()->DAO(),由于DAO长时间的I/O操作,导致该线程一直处于工作队列,但它又不占用CPU,则此时有1个CPU是处于空闲状态的。所以,这种情况下,应该加大线程池工作队列的长度(如果CPU调度算法使用的是FCFS,则无法切换),尽量不让CPU空闲下来,提高CPU利用率。
4. I/O密集型任务执行过程中，等待I/O的时间系那个对于其使用CPU的时间长，而处于I/O等待状态的线程并不会消耗CPU资源，对应线程池的大小可以调整为大于CPU核数，同时要注意的是I/O操作会引起上下文切换，核心池线程为1，最大线程池设置为2*CPU 核数，这样I/O操作带来的上下文切换是最少的。

- 参考文章：
    -[Java并发之——线程池](http://www.cnblogs.com/Eason-S/p/5721296.html)
    -[线程池线程数与(CPU密集型任务和I/O密集型任务)的关系](http://blog.csdn.net/lc0817/article/details/50706720)

## 4. 场景：抓取网页几T数据，查询网页中是否有java关键字，并且在文件中找出出现java频次比较高的文件，根据频次高低排序，找出最高的前几个文件。

> 1. 如何快速匹配关键词以及匹配

> 读取每行判断；使用多个线程，分割读取指定的大文件。获取我们所需要的信息。 

```
RandomAccessFile函数
randomFile.seek(start);跳跃读取，从这里开始读。
```

-参考文章：[java多线程读取大文件](http://blog.csdn.net/lxl870803/article/details/45527411)

> 2. 在海量文件中找出出现频率最高的前K个

针对top k类问题，通常比较好的方案是【分治+trie树/hash+小顶堆】，即先将数据集按照hash方法分解成多个小数据集，然后使用trie树或者hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出频率最高的前K个数，最后在所有top K中求出最终的top K。

> 3. 单机+单核+受限内存

这种情况下，需要将原数据文件切割成一个一个小文件，如，采用hash(x)%M，将原文件中的数据切割成M小文件，如果小文件仍大于内存大小，继续采用hash的方法对数据文件进行切割，直到每个小文件小于内存大小，这样，每个文件可放到内存中处理。

- 参考文章：
    -[怎样从10亿查询词找出出现频率最高的10个](http://dongxicheng.org/big-data/select-ten-from-billions/)

## 6. CPU对于线程的调度过程？

![](http://img.blog.csdn.net/20140901094537839?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9uZ3hpYW9qdW4xOTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

CPU的调度决策会发生在如下四种情况下：
（1）运行-->等待
（2）运行-->就绪
（3）等待-->就绪
（4）运行-->终止

1. 先来先服务（FCFS）
最简单的CPU调度算法，根据进程进入就绪队列的先后顺序调度进程执行。但是这种方法的平均等待时间通常较长。

2. 最短作业优先调度（SJF）
将每个进程与下一个CPU区间段相关联，当CPU空闲时，他回赋给具有最短CPU区间的进程。如果两个进程具有相同CPU区间长度，可以使用FCFS来调度。这里的CPU区间长度是进程的下一个CPU区间长度，而不是进程的CPU区间总长度。此算法可证明是最佳的，其难点在于如何知道进程的下一个CPU区间的长度。近似的情况下只能通过预测来做。

3. 优先级调度
每个进程都有一个优先级相关联，具有最高优先级的进程会被分配到CPU，具有相同优先级的进程根据FCFS顺序调度。实际上短作业优先就是优先级调度算法的一个特例。
优先级调度算法的一个主要问题是导致低优先级的进程产生无穷阻塞或饥饿（可以运行但是缺乏CPU），其解决问题之一就是老化，即以逐渐增加在系统中等待很长时间的进程的优先级。

4. 时间片轮转法调度（RR）
为分时系统而设计，类似于FCFS，不过每个进程只分配不超过一个时间片的CPU，对就绪队列中的进程依次循环分配时间执行。

5. 多级队列调度
将就绪队列中的进程根据进程的属性不同而永久分配到多个独立的队列中，每个队列都有自己的调度算法。同时队列中也有调度，通常采用固定优先级抢占调度。

6. 多级反馈队列调度
跟多级队列调度相似，最大的不同是允许进程在队列之间移动。主要思想是根据不同CPU区间的特点以区分进程，如果进程使用过多CPU时间，那么它会被转移到更低优先级队列。
多级反馈队列调度是最通用的CPU调度算法但是因为要设置很多调度参数，因此也是最复杂的算法。

- 参考文章：[进程、线程以及CPU调度](http://blog.csdn.net/lucienduan/article/details/49536431)

## 7. 如何控制多线程的并发？

> 在JDK中，提供了多种途径实现多线程间的并发控制。比如常用的：内部锁、重入锁、读写锁和信号量。

同步关键字synchronized是Java语言中最为常用的同步方法之一。
synchronized的用法：synchronized修饰方法和synchronized修饰代码块。

1. 当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

2. 然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。

3. 尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。

4. 第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。

5. 以上规则对其它对象锁同样适用.


**synchronized 修饰方法时锁定的是调用该方法的对象。它并不能使调用该方法的多个对象在执行顺序上互斥。**

```
public synchronized void method(){}
当method()方法被调用时，调用线程首先必须获得当前对象所，若当前对象锁被其他线程持有，这调用线程会等待，调用结束后，对象锁会被释放，以上方法等价于下面的写法：

public void method(){
synchronized(this){
// do something …
}
}

public synchronized static void method(){}
这个地方一定要注意，synchronized的锁是加在 当前Class对象 上，因此，所有对该方法的调用，都必须获得Class对象的锁。
```

synchronized的缺陷：当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待。这是一个致命的问题。

- 参考文章：[JAVA 同步之 synchronized 修饰方法](http://www.cnblogs.com/hapjin/p/4678773.html)

## 8. MySQL的索引的结构？

> MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。

> MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。

> MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

> InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

> 聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

> 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

## 9. InnoDB中所有的索引都是B+树吗？普通索引是什么样子的？

> innodb存储引擎支持两种常见的索引：B+树索引和哈希索引。
innodb支持哈希索引是自适应的，innodb会根据表的使用情况自动生成哈希索引。

> 哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

> Mysql各种索引区别：
1. 普通索引：最基本的索引，没有任何限制
2. 唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。
3. 主键索引：它是一种特殊的唯一索引，不允许有空值。 
4. 全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。
5. 组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。

## 10. 聚簇索引与非聚簇索引的区别？

> 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

> 聚簇索引是顺序结构与数据存储物理结构一致的一种索引，并且一个表的聚簇索引只能有唯一的一条。

> 非聚簇索引记录的物理顺序与逻辑顺序没有必然的联系，与数据的存储物理结构没有关系；一个表对应的非聚簇索引可以有多条，根据不同列的约束可以建立不同要求的非聚簇索引。

## 11. 一张大表千万级数据，如何实现性能比较高的分页查询？

```
分页查询语句：
SELECT * FROM 表名称 LIMIT M,N
```
原因/缺点: 全表扫描,速度会很慢 且有的数据库结果集返回不稳定(如某次返回1,2,3,另外的一次返回2,1,3). Limit限制的是从结果集的M位置处取出N条输出,其余抛弃。

> OFFSET过大导致MySQL耗费了大量随机I/O在查询聚簇索引的数据上。

> 改进措施：

1. 利用覆盖索引的查询。
```
SELECT * FROM product WHERE ID > =(select id from product limit 866613, 1) limit 20

SELECT * FROM product a JOIN (select id from product limit 866613, 20) b ON a.ID = b.id

```

2. 复合索引
> 如果对于有where 条件，又想走索引用limit的，必须设计一个索引，将where 放第一位，limit用到的主键放第2位，而且只能select主键！

> 利用MySQL支持ORDER操作可以利用索引快速定位部分元组,避免全表扫描
```
SELECT * FROM your_table WHERE pk>=1000 ORDER BY pk ASC LIMIT 0,20
```

## 12. MySQL事务由哪些特性？

> 事务的四大特性（ACID）：
1. 原子性（atomicity）：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。
2. 一致性（consistency）：数据库总数从一个一致性的状态转换到另一个一致性的状态。
3. 隔离性（isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。
4. 持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

> 数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。

## 13. Linux分析日志，例如nginx中access.log中请求前100的IP有哪些？如果nginx日志过大如何处理？

```
awk '{print $1}' access.log | sort -n |uniq -c | sort -rn | head -n 100
```

> 编辑每日定时脚本，切割日志日志（根据服务器内存大小指定分割大小），然后压缩一下。这样磁盘空间以及内存占用占用就小了。

```
#!/bin/bash local_path=/home/work/tp/log/webserver #找到您服务器中存放access日志的目录 
cd $local_path #进入这个目录 

mv access_log $local_path/access_log` date +%Y%m%d%H` #把当前的access_log挪到这个时期下，其实就是相当于日志的切分 

nginx_pid=`ps -ef |grep -v grep |grep “nginx: master process “|awk -F” ” ‘{print $2}’` #找到您nginx的进程 `

kill -USR1 $nginx_pid` #执行usr1
```
通过定时任务来让这个nginx_time.sh脚本按每小时来进行切分
```
0 */1 * * * sh /xxx(您这个脚本的存放命令)/nginx.sh 按每小时切割
```

- 参考文章：[nginx中access日志如何做到按时间完美切割](http://www.imooc.com/article/18022)

## 14. 照常的提问环节~
