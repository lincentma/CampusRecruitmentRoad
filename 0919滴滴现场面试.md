# 滴滴现场面试记录

> 现在写下的感受：完成了一场酣畅淋漓的运动之后的感觉，累然而爽。

## 一面

1. 操作系统进程的状态，注意不是线程！

> 进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。在三态模型中，进程状态分为三个基本状态，即运行态，就绪态，阻塞态。在五态模型中，进程分为新建态、终止态，运行态，就绪态，阻塞态。

> 1. 运行状态：获得CPU的进程处于此状态，对应的程序在CPU上运行着

> 2. 阻塞状态：为了等待某个外部事件的发生（如等待I/O操作的完成，等待另一个进程发来消息），暂时无法运行。也称为等待状态。

> 3. 就绪状态：具备了一切运行需要的条件，由于其他进程占用CPU而暂时无法运行

![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=6803c224f2edab64607f4592965fc4a6/b7003af33a87e950f9264f8319385343fbf2b428.jpg)

> 五态模型：对于一个实际的系统，进程的状态及其转换更为复杂。引入新建态和终止态构成了进程的五态模型。
![](http://s8.sinaimg.cn/middle/7c03bb1fh78d58c467517&690)

> 致使进程阻塞的典型事件有：请求I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而把处于阻塞状态的进程排成多个队列。


2. TCP三次握手详细画图，为什么每一次要加一？最后一次需不需要加一？

> TCP 头部格式：

![](http://picture.jellythink.com/jellythinkTCP3.jpg)

- Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；

- Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；

- Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题；

- Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；

- TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：
    - URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；
    - ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；
    - PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；
    - RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；
    - SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；
    - FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。

- Window:窗口大小，也就是有名的滑动窗口，用来进行流量控制；

![](http://picture.jellythink.com/jellythinkTCP4.jpg)

> 第二次和第三次握手有：Acknowledgment Number为x+1(Sequence Number+1)

> 第二次：服务端响应客户端的请求，响应中附带序列号0（由于这是服务端在该次TCP会话中发送的第一个包，所以序列号为0）和相对确认号1（表明服务端收到了客户端发送的包1中的SYN）

> 需要注意的是，尽管客户端没有发送任何有效数据，确认号还是被加1，这是因为接收的包中包含SYN或FIN标志位（并不会对有效数据的计数产生影响，因为含有SYN或FIN标志位的包并不携带有效数据）

> 第三次：和包2中一样，客户端使用确认号1响应服务端的序列号0，同时响应中也包含了客户端自己的序列号（由于服务端发送的包中确认收到了客户端发送的SYN，故客户端的序列号由0变为1）
此时，通信的两端的序列号都为1，通信两端的序列号增1发生在所有TCP会话的建立过程中。

> 这张图说明了一切：
![](http://img.blog.csdn.net/20140725104320005?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

- 参考文章：[理解TCP序列号（Sequence Number）和确认号（Acknowledgment Number）](http://blog.csdn.net/a19881029/article/details/38091243)

3. 排序算法

4. 概率题

5. 划重点：详细介绍运维所做的事情，草稿纸找不到了，非常感谢一面面试官！

> 首先是服务层的稳定性，运维是作为服务上线最后一道把关人，确保服务的高可用性。

> 再是系统资源层面的稳定性，包括机器的CPU占用，I/O读取等稳定。

> 然后是系统的高效性。利用docker等虚拟化等技术来节约资源。

> ...


## 二面

1. 针对实习项目，展开优化策略：

- 后端请求打到相同机器如何进行优化？

> 网上找到这样的图，描绘的很形象：将请求放入队列中的，采用FIFO（First Input First Output，先进先出）

![](http://cms.csdnimg.cn/article/201411/28/547823786991a_middle.jpg?_=10168)

> 系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时候还是会大幅下降，系统还是陷入异常。

> 乐观锁

- 如何Hash分散请求？

> 一致性哈希。

> 一致性哈希，其实就是把哈希函数可映射的空间(相当于普通哈希中桶的数目是固定的)固定下来了，比如固定为: 2^n - 1，并组织成环的形状。每个机器对应着一个n位的ID，并且映射到环中。每个查询键，也是一个 n 位的ID，节点的ID和查询键对应着相同的映射空间。

> 一致性哈希的好处就是：当添加新机器或者删除机器时，不会影响到全部数据的存储，而只是影响到这台机器上所存储的数据(落在这台机器所负责的环上的数据)。

> 步骤：
1. 将整个哈希值空间组织成一个虚拟圆环，假设某哈希函数H的值空间为0-(2^32-1)，即32位无符号整数
2. 将各节点用H函数哈希，可以将服务器的IP或主机名作为关键字哈希，这样每个节点就能确定其在哈希环上的位置
3. 将id用H函数映射到哈希空间的一个值，沿该值向后，将遇到的第一个节点做为处理节点

![](http://s9.sinaimg.cn/middle/3fde8252hc784bc9cd088&690) 

> 引入虚拟节点，可以有效地防止物理节点(机器)映射到哈希环中出现不均匀的情况。

2. 划重点：普及AIOPs概念，详细介绍Google，百度在AIOPs的尝试以及最近运维大会讨论的主题，非常感谢二面面试官！

> 目前是自动化运维：DevOps
> AIOps应用场景较少，主要在于异常检测
> 运维的稳定性是最重要的，但是AIOps的模型训练的试错成本很高，这是一个矛盾。
> Google:SRE；百度运维；阿里运维。国内做的比较好的~

> SRE是Site Reliability Engineer的简称，从名字可以看出Google的SRE不只是做Operation方面的工作，更多是保障整个Google服务的稳定性。SRE需要负责可用性、时延、性能、效率、变更管理、监控、应急响应和容量管理等相关的工作。

### 三面

> 三面面试官在深度细节方面让自己更加了解自己的不足

1. 给定数组，乱序，重复，如何找到重复次数超过数组长度一半的数字？

> 参考文章：[数组中出现次数超过一半的数字](https://www.nowcoder.com/questionTerminal/e8a1b01a2df14cb2b228b30ee6a92163?source=relative)

> 数组排序后，如果符合条件的数存在，则一定是数组中间那个数。

> 采用阵地攻守的思想：
第一个数字作为第一个士兵，守阵地；count = 1；
遇到相同元素，count++;
遇到不相同元素，即为敌人，同归于尽,count--；
当遇到count为0的情况，又以新的i值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，有可能是主元素。
再加一次循环，记录这个士兵的个数看是否大于数组一半即可。

```
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        int length=array.length;
        if(array==null||length<=0){
            return 0;
        }
        
        int result=array[0];
        int times=1;
        for(int i=1;i<length;i++){
            if(times==0){
                result=array[i];
                times=1;
            }else{
                if(array[i]==result){
                    times++;
                }else{
                    times--;
                }
            }
        }
        
        times=0;
        for(int i=0;i<length;i++){
            if(result==array[i]){
                times++;
            }
       }
            
       if(times*2<length){
           result=0;
       }
       return result;
    }
}

```


> map方法：

```
import java.util.HashMap;
import java.util.Map;
/*
 * 利用map存值，找出存在最多的数字，若大于长度一半，返回此数，否则返回0
 */
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        if(array.length==0||array==null)
            return 0;
        Map<Integer,Integer> map=new HashMap<Integer,Integer>();
        for(int i=0;i<array.length;i++){
            if(map.containsKey(array[i])){
                map.put(array[i], map.get(array[i])+1);
            }else{
                map.put(array[i], 1);
            }
        }
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) { 
            if(entry.getValue()>array.length/2)
                return entry.getKey();
        } 
        return 0;
    }
}
```

2. 为什么要这样设计？时间复杂度是多少？还有没有别的方法？

> 最优O(n)

3. 8个球其中一个质量轻，给一个天平，如何2次称出质量轻的球？

- 第一次,天平两边各放三个球：

    1.1 如果两边重量一致,则有质量缺陷的球在剩余的两个中---转至“2.2”

    1.2 如果两边重量不一致,则有质量缺陷的球在较轻重量的三个中----转至“2.1”

- 第二次：

    2.1 在较轻的三个中取两个放在天平两边,如天平平衡,那么第三个球是有质量缺陷的球；如果不平衡,那么,较轻的是有质量缺陷的球.

    2.2 将剩余的两个球放在天平两边,较轻的是有质量缺陷的.

4. 你眼中的运维？

> 运维服务于整个产品，保证架构合理，系统稳定。运维只对业务稳定负责，所有的工作都是奔着这个去的。

- 参考文章：[一个开发眼中的运维](https://segmentfault.com/a/1190000000348370)

5. 你认为自己的优势是什么？

> 自信。



#### HR面

> “自己缺乏的是对于对方表达意思的深刻理解”，非常高兴能够从HR面试中发现自己的不足，虽然这会影响到HR对于自己的评价，但是自己还是明白了。

1. 如何沟通？

> 首先是换位思考，明白提问者想要的结果；其次是确认，确认自己的理解正确；最后总结自己的回答。

2. 如何克服困难？

> 问题在于克服的方式。通过工具？通过合作？等待，具体事例辅佐。

3. 什么时候压力大？来源是什么？

> 问题不在克服问题的流程，在于压力来源原因的分析，最后辅以客服的案例。

3. 为什么选择运维？然而你的经历是后端？

> 今天的经历告诉自己，缘分。哈哈~

4. 自己的问的问题。