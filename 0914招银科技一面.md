# 招银科技一面

> 主要是基础知识，有些细节自己没有掌握牢固，温故知新

# 基础知识

### 1. 你了解过Java的序列化吗？

> Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。

### 2. Java序列化的用途以及使用场景？

> 1.当对象需要被网络传输时
> 2.对象状态需要被持久化时

> 围绕根本，就有很多实际的拓展应用，例如：

> tomcat服务器会在服务器关闭时把session序列化存储到tomcat目录一个名为session.ser的文件中，这个过程成为session的钝化，因为有些时候当我们要重新部署项目的时候，有的用户可能在访问，这样做的目的是服务器重启之后tomcat可以反序列化这个session.ser文件，将session对象重新生成出来，用户可以使用部署之前的session进行操作，这个反序列化的过程成为session的活化。

> 分布式应用。

### 3. 类序列化需要实现什么接口？

> Serializable接口。

### 4. 该类实现了这个接口，那么子类可以序列化吗？

> 父类实现了Serializable，子类不需要实现Serializable接口。

### 5. 当序列化后修改serialVersionUID，还可以反序列化回来吗?

> 序列化的时候系统会把当前类的serialVersionUID 写入序列化的文件中（也可能是其他中介），当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化，否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量，类型可能发生了改变，这个时候就会抛异常，反序列化失败。

> 默认情况下，也就是不声明serialVersionUID属性情况下，系统会按当前类的成员变量计算hash值并赋值给serialVersionUID。声明serialVersionUID，可以很大程度上避免反序列化过程的失败。比如当版本升级后，我们可能删除了某个成员变量，也可能增加了一些新的成员变量，这个时候我们的反序列化依然能够成功，程序依然能够最大程度地恢复数据，相反，如果不指定serialVersionUID，程序就会挂掉。当然我们还要考虑另外一种情况，如果类结构发生了非常规性改变，比如修改了类名，类型等，这个时候尽管serialVersionUID验证通过了，但是反序列化过程还是会失败，因为类结构有了毁灭性的改变。

> serialVersionUID一般默认设置为固定的 1L。

> Java序列化允许java类中的一些变化，如果他们可以被忽略的话。一些不会影响到反序列化处理的变化有：
> 1. 在类中添加一些新的变量。
> 2. 将变量从transient转变为非tansient，对于序列化来说，就像是新加入了一个变量而已。
> 3. 将变量从静态的转变为非静态的，对于序列化来说，就也像是新加入了一个变量而已。

> 总结，serialVersionUID不一致，反序列化报错。对象序列化后更改值同样也可以读取到，序列化并不保存静态变量，可以接受一些类变量的增加操作不影响反序列化。

### 6. Java序列化相对于其他数据交换的方式有哪些缺点？

> Java序列化写入不仅是完整的类名，也包含整个类的定义，包含所有被引用的类。一旦类定义较多，空间占用大。
同时Java序列化为二进制对文件，序列化后内容都是不可读的，这会对系统的排错造成一定的影响。
> 优点是转换效率高。

> JSON以固定的格式，稳定简单的数据结构大大简化了序列化过程。
> 缺点是转换效率低。

### 7. classloader加载类的机制是什么？

> 遵循委派双亲加载。通过调用loadClass方法逐级往上传递委派加载请求，当找不到父ClassLoader时调用其findClass方法尝试进行查找和加载，如果当前ClassLoader找不所需的Class,则由其孩子尝试进行查找和加载，如果当前ClassLoader找了所需的Class则将该Class按请求路径逐级返回孩子。

### 8. 你的意思是jar包中的类不一定会全部加载？系统提供(例如JDK、String)的类是由哪一个加载器加载的？EXT加载哪些类？如果我自定义一个类加载区，它的父加载区是哪一个？

> Java动态加载。Bootstrap ClassLoader。EXT加载JRE\lib\ext\*.jar。拥堵自定义的类加载器的父类为系统加载器。

> ![](http://images.cnitblog.com/blog/347002/201502/110912451518649.gif)

> JVM本身包含了一个ClassLoader称为Bootstrap ClassLoader，和JVM一样，BootstrapClassLoader是用本地代码实现的，它负责加载核心JavaClass(即所有java.*开头的类)。——Load JRE\lib\rt.jar

> 另外JVM还会提供两个ClassLoader，它们都是用Java语言编写的，由BootstrapClassLoader加载;其中Extension ClassLoader负责加载扩展的Javaclass(例如所有javax.*开头的类和存放在JRE的ext目录下的类)

> ApplicationClassLoader负责加载应用程序自身的类。

### 9. classLoad加载class文件一般分为哪几个阶段？

> 当使用到某个类，但该类还未初始化，未加载到内存中时会经历类加载、链接、初始化三个步骤完成类的初始化。

> 类加载：
* 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器。
只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。

> 类的链接：
* 当类加载完成后，系统会给为之生成一个对象；随后进入链接阶段，链接阶段负责把类的二进制数据添加到JRE中。三个阶段：
* 验证：检验被加载的类是否有正确的内部结构，并和其他类协调一致
* 准备：负责为类的类变量分配内存。并设置默认初始值
* 解析：将类的二进制数据中的符号引用替换成直接引用

> 类的初始化：JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：

* 声明类变量是指定初始值
* 使用静态代码块为类变量指定初始值
* JVM初始化步骤
* 假如这个类还没有被加载和连接，则程序先加载并连接该类
* 假如该类的直接父类还没有被初始化，则先初始化其直接父类
* 假如类中有初始化语句，则系统依次执行这些初始化语句

### 10. 数据库试图的作用？视图中的数据是存在视图中的吗？

> 这个回答的不好。

> 视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。

> 1. 视图能简化用户操作
> 2. 视图使用户能以多种角度看待同一数据
> 3. 视图对重构数据库提供了一定程度的逻辑独立性
> 4. 视图能够对机密数据提供安全保护

### 11. 视图的更新有没有一些限制？

> 没有回答上来

> 利用数据库视图进行更新实质上就是对数据库的基本表进行更新。所以视图的更新update命令有很多限制。

1. 若视图是由两个以上基本表导出的，则此视图不允许更新
2. 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE
3. 若视图字段来自聚集函数，则此视图不允许更新
4. 若视图定义中含有GROUP BY 子句，则此视图不允许更新
5. 若视图中含有DISTINCT语句，则此视图不允许更新
6. 若视图定义中含有嵌套查询，并且内层查询的FROM子句涉及的表也是导出该视图的基本表，则此视图不允许更新
7. 一个不允许更新的视图上定义的视图也不允许更新

### 12. 内联结和外联结的区别？

> 内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的 
列值。

> 外连接，返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左 
外连接或左连接))、右表(右外连接或右连接)或两个边接表(全外连接)中的所有数据行。 
* left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录； 
* right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录。

### 13. 索引的作用

> 优点：
1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 
2. 可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。 
3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 
4. 在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 
5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

> 缺点：
1. 创建索引和维护索引要耗费时间，这种时间随着数据 量的增加而增加。 
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

### 14. 索引一定会加快检索速度吗？

> 1. 对于那些在查询中很少使用或者参考的列不应该创建索引。这是因 为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 
> 2. 对于那 些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比 例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 
> 3. 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 
> 4. 当修改性能远远大于检索性能时，不应该创建索 引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因 此，当修改性能远远大于检索性能时，不应该创建索引。

### 15. 数据库的锁分为哪几种？

> 锁的类型有三种： 

> 共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。 

> 排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。 

> 更新（U)锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。

### 16. 幻读产生场景？一般出现在什么样的事务中？

> 不可重复读取(Non-Repeatable Reads):  A 事务两次读取同一数据，B事务也读取这同一数据，但是 A 事务在第二次读取前B事务已经更新了这一数据。所以对于A事务来说，它第一次和第二次读取到的这一数据可能就不一致了。

> 幻读(Phantom Reads): 与不可重复读有点类似，都是两次读取，不同的是 A 事务第一次操作的比如说是全表的数据，此时 B 事务并不是只修改某一具体数据而是插入了一条新数据，而后 A 事务第二次读取这全表的时候就发现比上一次多了一条数据，发生幻觉了。

> 数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 读未提交 、Read committed 读提交 、Repeatable read 重复读 、Serializable 序列化 ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。

> 幻读出现在前三个级别中。不可重复读出现在前两个级别中。脏读出现在第一个级别中。

### 17. TCP如何保证重传？

> 每一次发送一个片段，就开启一个重传计时器。计时器有一个初始值并随时间递减。如果在片段接收到确认之前计时器超时，就重传片段。

> 1. 放置于重传队列中，计时器开始 包含数据的片段一经发送，片段的一份复制就放在名为重传队列的数据结构中，此时启动重传计时器。因此，在某些时间点，每一个片段都会放在队列里。队列按照重传计时器的剩余时间来排列，因此TCP软件可追踪那几个计时器在最短时间内超时。

> 2. 确认处理 如果在计时器超时之前收到了确认信息，则该片段从重传队列中移除。

> 3. 重传超时 如果在计时器超时之前没有收到确认信息，则发生重传超时，片段自动重传。当然，相比于原片段，对于重传片段并没有更多的保障机制。因此，重传之后该片段还是保留在重传队列里。重传计时器被重启，重新开始倒计时。如果重传之后没有收到确认，则片段会再次重传并重复这一过程。在某些情况下重传也会失败。我们不想要TCP永远重传下去，因此TCP只会重传一定数量的次数，并判断出现故障终止连接。

### 18. 域名解析过程？

> 1. 在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 
> 2. 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 
> 3. 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 
> 4. 如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 
> 5. 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。 
> 6. 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 

> 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。





